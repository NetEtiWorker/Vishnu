using System;
using System.Reflection;
using System.IO;
using System.Linq;
using NetEti.ApplicationControl;
using NetEti.Globals;
using System.Collections.Generic;
using Vishnu.Interchange;
using System.Collections.Concurrent;

namespace Vishnu.Interchange
{
  /// <summary>
  /// Funktion: Stellt Methoden für das dynamische Laden von
  /// Assemblies und das Instanziieren darin enthaltener Klassen
  /// zur Verfügung.
  /// </summary>
  /// <remarks>
  /// File: VishnuAssemblyLoader.cs
  /// Autor: Erik Nagel
  ///
  /// 10.04.2013 Erik Nagel: erstellt
  /// </remarks>
  public class VishnuAssemblyLoader
  {
    #region public members

    /// <summary>
    /// Singleton-Provider - übernimmt Pfade zu Verzeichnissen, in denen zusätzlich
    /// nach Assemblies gesucht werden soll.
    /// </summary>
    /// <returns>Singleton-Instanz von AssemblyLoader</returns>
    public static VishnuAssemblyLoader GetAssemblyLoader()
    {
      VishnuAssemblyLoader loader = NestedInstance.itsMe;
      loader._assemblyDirectories = GenericSingletonProvider.GetInstance<AppSettings>().AssemblyDirectories;
      return (loader);
    }

    /// <summary>
    /// Lädt ein Objekt vom übergebenen Typ aus der angegebenen Assembly dynamisch.
    /// Alle von der angegebenen Assembly referenzierten Assemblies werden zusätzlich
    /// auch in assemblyDirectories gesucht.
    /// </summary>
    /// <param name="assemblyPathName">Die Assembly, die das zu ladende Objekt publiziert.</param>
    /// <param name="objectType">Der Typ des aus der Assembly zu instanzierenden Objekts</param>
    /// <returns>Instanz aus der übergebenen Assembly vom übergebenen Typ oder null</returns>
    public object DynamicLoadObjectOfTypeFromAssembly(string assemblyPathName, Type objectType)
    {
      object candidate = null;
      try
      {
        Assembly slave = dynamicLoadAssembly(assemblyPathName, false);
        if (slave != null)
        {
          Type[] exports = slave.GetExportedTypes();
          foreach (Type type in exports)
          {
            if (objectType.IsAssignableFrom(type))
            {
              try
              {
                candidate = Activator.CreateInstance(type);
              }
              catch { }
            }
            if (candidate != null)
            {
              break;
            }
          }
        }
        return candidate;
      }
#if DEBUG
      catch (Exception ex)
      {
        InfoController.Say("Could not load " + assemblyPathName + Environment.NewLine + ex.Message.ToString());
      }
#else
      catch (Exception) { }
#endif
      return null;
    }

    /// <summary>
    /// Lädt ein Objekt vom übergebenen Typ aus der angegebenen Assembly dynamisch.
    /// Alle von der angegebenen Assembly referenzierten Assemblies werden zusätzlich
    /// auch in assemblyDirectories gesucht.
    /// </summary>
    /// <param name="dllPath">Die Assembly, die das zu ladende Objekt publiziert.</param>
    /// <param name="objectType">Der Typ des aus der Assembly zu instanzierenden Objekts</param>
    /// <returns>Instanz aus der übergebenen Assembly vom übergebenen Typ oder null</returns>
    public object DirectLoadObjectOfTypeFromAssembly(string dllPath, Type objectType)
    {
      object candidate = null;
      try
      {
        Assembly slave = directLoadAssembly(dllPath, false);
        if (slave != null)
        {
          Type[] exports = slave.GetExportedTypes();
          foreach (Type type in exports)
          {
            if (objectType.IsAssignableFrom(type))
            {
              try
              {
                candidate = Activator.CreateInstance(type);
              }
              catch { }
              if (candidate != null)
              {
                break;
              }
            }
          }
        }
        return candidate;
      }
#if DEBUG
      catch (Exception ex)
      {
        InfoController.Say("Could not load " + dllPath + Environment.NewLine + ex.Message.ToString());
      }
#else
      catch (Exception) { }
#endif
      return null;
    }

    #endregion public members

    #region private members

    private List<string> _assemblyDirectories;

    static ConcurrentDictionary<string, KeyValuePair<Assembly, int>> LoadedAssembliesByNameAndChangeCount;
    const int MAXASSEMBLYRELOADS = 2;

    /// <summary>
    /// Statischer Konstruktor.
    /// </summary>
    static VishnuAssemblyLoader()
    {
      LoadedAssembliesByNameAndChangeCount = new ConcurrentDictionary<string, KeyValuePair<Assembly, int>>();
    }

    /// <summary>
    /// Lädt die Assembly vom übergebenen Pfad.
    /// </summary>
    /// <param name="slavePathName">Pfad der zu ladenden Assembly.</param>
    /// <param name="quiet">Keine Meldung bei Misserfolg.</param>
    /// <returns>Geladene Assembly oder null</returns>
    private Assembly dynamicLoadAssembly(string slavePathName, bool quiet)
    {
      Assembly candidate = null;
      foreach (string assemblyDirectory in (new List<string> { "" }).Union(this._assemblyDirectories))
      {
        string dllPath = Path.Combine(assemblyDirectory, slavePathName).Replace(@"Plugin\Plugin", "Plugin");
        if (!dllPath.ToLower().EndsWith(".dll"))
        {
          dllPath += ".dll";
        }
        candidate = this.directLoadAssembly(dllPath, quiet);
        if (candidate != null)
        {
          break;
        }
      }
      if (candidate == null)
      {
        if (!quiet)
        {
#if DEBUG 
          InfoController.Say("Could not embed " + slavePathName);
#endif
        }
      }
      return candidate;
    }

    private Assembly directLoadAssembly(string dllPath, bool quiet)
    {
      Assembly candidate = null;
      if (File.Exists(dllPath))
      {
        candidate = null;
        try
        {
          ThreadLocker.LockNameGlobal("AssemblyLoader");
          // Gibt die Dll im Filesystem direkt nach Laden wieder frei.
          if (VishnuAssemblyLoader.LoadedAssembliesByNameAndChangeCount.ContainsKey(dllPath)
            && (VishnuAssemblyLoader.LoadedAssembliesByNameAndChangeCount[dllPath].Value) > MAXASSEMBLYRELOADS)
          {
            candidate = (Assembly)VishnuAssemblyLoader.LoadedAssembliesByNameAndChangeCount[dllPath].Key;
          }
          else
          {
            candidate = System.Reflection.Assembly.Load(System.IO.File.ReadAllBytes(dllPath));
            int loadedCounter = 0;
            if (!VishnuAssemblyLoader.LoadedAssembliesByNameAndChangeCount.ContainsKey(dllPath))
            {
              VishnuAssemblyLoader.LoadedAssembliesByNameAndChangeCount.TryAdd(dllPath, new KeyValuePair<Assembly, int>(candidate, 0));
            }
            else
            {
              loadedCounter = VishnuAssemblyLoader.LoadedAssembliesByNameAndChangeCount[dllPath].Value;
            }
            VishnuAssemblyLoader.LoadedAssembliesByNameAndChangeCount[dllPath] = new KeyValuePair<Assembly, int>(candidate, ++loadedCounter);
          }
          // Blockt die Dll im Filesystem nach Laden solange, wie die Applikation läuft.
          // candidate = Assembly.LoadFrom(slavePathName);
        }
        catch { }
        finally
        {
          ThreadLocker.UnlockNameGlobal("AssemblyLoader");
        }
      }
      return candidate;
    }

    /// <summary>
    /// Privater Konstruktor.
    /// </summary>
    private VishnuAssemblyLoader()
    {
      AppDomain currentDomain = AppDomain.CurrentDomain;
      currentDomain.AssemblyResolve += new ResolveEventHandler(myResolveEventHandler);
    }

    private Assembly myResolveEventHandler(object sender, ResolveEventArgs args)
    {
      return dynamicLoadAssembly(args.Name.Split(',')[0], true);
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses", Justification = "due to lazyness of the singleton instance")]
    private class NestedInstance
    {
      internal static readonly VishnuAssemblyLoader itsMe;

      [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline", Justification = "due to lazyness of the singleton instance")]
      static NestedInstance()
      {
        itsMe = new VishnuAssemblyLoader();
      }
    }

    #endregion private members

  }
}
